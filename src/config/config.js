const fs = require('fs');
const path = require('path');

class Config {
  constructor() {
    this.defaults = {
      mainBranch: "main",
      todoColumn: "For Agent",
      progressColumn: "In Progress",
      reviewColumn: "Review",
      completedColumn: "Done",
      pollInterval: 30000,
      backlogPath: "./backlog/tasks",
      autoStart: false,
      notifications: true,
      maxConcurrentTasks: 1,
      branchPrefix: "task",
      timeout: 300000, // 5 minutes
    };

    this.config = { ...this.defaults };
    this.load();
  }

  load() {
    const configPath = path.join(process.cwd(), '.backlog-runner.json');
    if (fs.existsSync(configPath)) {
      try {
        const userConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        this.config = { ...this.defaults, ...userConfig };
      } catch (error) {
        console.warn('Warning: Invalid config file, using defaults');
      }
    }
  }

  get(key) {
    return this.config[key];
  }

  set(key, value) {
    this.config[key] = value;
  }

  getAll() {
    return { ...this.config };
  }

  save() {
    const configPath = path.join(process.cwd(), '.backlog-runner.json');
    const configToSave = { ...this.config };

    // Remove defaults that haven't changed
    Object.keys(this.defaults).forEach(key => {
      if (configToSave[key] === this.defaults[key]) {
        delete configToSave[key];
      }
    });

    fs.writeFileSync(configPath, JSON.stringify(configToSave, null, 2));
  }

  // Template functions
  getOpenCodeTemplate(task, isRevision = false) {
    return `
Task: ${task.title}
ID: ${task.id}
${task.description ? `Description: ${task.description}` : ''}

${isRevision ? `
üîÑ REVISION REQUEST
Please address the feedback provided in the task description and improve the implementation.
Review the existing code carefully and make necessary improvements.
Consider the previous implementation and what might have been missed.
` : `
‚ú® NEW IMPLEMENTATION
Please implement this task following these guidelines:
1. üîç Analyze the current codebase and understand the requirements
2. üíª Implement the necessary changes with clean, maintainable code
3. üß™ Write appropriate tests if needed
4. üìè Ensure code follows project conventions and best practices
5. üìù Make atomic commits with descriptive messages
6. üöÄ Consider performance and scalability implications
`}

${task.labels && task.labels.length > 0 ? `
üè∑Ô∏è Special considerations: ${task.labels.join(', ')}
` : ''}
${task.priority ? `‚ö° Priority: ${task.priority}\n` : ''}
${task.estimatedTime ? `‚è±Ô∏è Estimated time: ${task.estimatedTime}\n` : ''}

Focus on quality and completeness. When finished, ensure all changes are committed properly.
Think step by step and explain your approach before implementing.
`.trim();
  }

  getCommitMessage(task, isRevision) {
    return isRevision
      ? `fix: address feedback for ${task.title}`
      : `feat: implement ${task.title}`;
  }

  getPRTemplate(task) {
    return {
      title: `${task.labels.includes('bug') ? 'fix' : 'feat'}: ${task.title}`,
      body: `${task.description}\n\n---\n\n**Task ID:** ${task.id}\n**Auto-generated by:** Backlog Runner`
    };
  }
}

module.exports = new Config();
